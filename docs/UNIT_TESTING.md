# Testing For AlignmentViewer 2.0

We are using [Jest](https://facebook.github.io/jest) as our unit testing framework our choice.

## Enzyme

As of this writing, we are using [Create React App](https://create-react-app.dev/) as a foundation and [enzyme](https://airbnb.io/enzyme/) for rendering components. The former has a lot of configuration baked, but is missing a piece for the latter works with this [proposed solution](https://create-react-app.dev/docs/running-tests/#srcsetuptestsjs)). In short, the following global configuration is applied in `src/setuptests.js`:

```js
import Enzyme from "enzyme";
import Adapter from "enzyme-adapter-react-16";
Enzyme.configure({ adapter: new Adapter() });
```

## Random UUIDs generated by the `crypto` module

Out of the box, the `crypto` module is not available during testing. In addition, having random UUIDs during testing causes snapshot matching to always fail due to the uniqueness of each snapshot. To fix this, we update `src/setuptests.js` to (1) add the `crypto` module to the `global` property and (2) modify the modules `getRandomValues` function to always return the same value:

```js
const crypto = require("crypto");
Object.defineProperty(global, "crypto", {
  value: {
    getRandomValues: (arr) => {
      return new Array(arr).map((num) => {
        return 0;
      });
    },
  },
});
```

## Canvas and WebGL

If testing a component using the canvas and/or dealing with WebGL components, it is necessary to have it mocked out since the tests are running in [jsdom](https://github.com/jsdom/jsdom), a virtual browser.

The remedy is to import [this library](https://www.npmjs.com/package/jest-webgl-canvas-mock) at the top of your file:

```ts
import "jest-webgl-canvas-mock";
```

## Fetching

When the code makes a `fetch` request, or similar network call, the test will most likely need to have said `fetch` calls mocked. We use [jest-fetch-mock](https://www.npmjs.com/package/jest-fetch-mock) to do this, and it's pretty powerful!

In order to use it, you need to include these lines in your file:

```ts
import { enableFetchMocks, default as fetchMock } from "jest-fetch-mock";
enableFetchMocks();
```

Let's look at a simple example:

```ts
import { enableFetchMocks, default as fetchMock } from "jest-fetch-mock";
enableFetchMocks();

describe("Example", () => {
  beforeAll(async () => {
    fetchMock.mockResponse("Every fetch request will return me!");
  });
});
```

## Bringing it All Together

Here is an example of the above imports all working together in unison in a more realistic scenario, albeit with a made-up component:

```tsx
import "jest-webgl-canvas-mock";

import { shallow, mount, default as Enzyme } from "enzyme";
import Adapter from "enzyme-adapter-react-16";
Enzyme.configure({ adapter: new Adapter() });

import { enableFetchMocks, default as fetchMock } from "jest-fetch-mock";
enableFetchMocks();

import * as fs from "fs";

describe("SequenceComponent", () => {
  beforeAll(async () => {
    const sequenceFile = fs.readFileSync("an-example-file.a2m").toString();
  });

  it("Should match the existing snapshot.", () => {
    const wrapper = shallow(<SequenceComponent />);
    expect(wrapper).toMatchInlineSnapshot(`
<div
  className="SequenceComponent"
  sequenceFileLocation="an-example-file.a2m"
>
  <canvas />
</div>
    `);
  });
});
```
